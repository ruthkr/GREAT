---
title: "Gene registration -- after getting all stretch and shift"
output: 
  github_document:
    toc: true
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
library(GREAT)
library(ggplot2)
library(data.table)
```

## Background

In this Rmd file, I tried to understand the process after getting all stretch and shift. 


## Initialise some parameters

```{r}
jobNum <- 1 # if running lots of times on cluster to get enough shuffled results, then jobNum is used to prevent output overwriting
do.initial_rescale <- 'nope' # should be 'rescale' if want to use scaled df for registration, rather than mean_df
do.register.rescale <- 'rescale' # should be 'rescale' if want to rescale using only the overlapping points during  registration
shuffle.type <- 'shuffle.expression' # whether should shuffle by shuffling the gene ids compared, or by shuffling the gene expression
# for each gene c('shuffle.genes', or 'shuffle.expression)

outdir.string <- 'TESTING_rescale_as_register___shuffled_g_v4__'
```

```{r}
# calculate the scores associated with each candidate shift
# Arabidopsis observations = 7d -> 16d = 0d -> 9d
# Ro18 observations = 11d -> 35d = 0d -> 24d
# therefore if same start and end points stretch = 24 / 9

# lots of spurious overlaps detected when too extreme shifts allowed
stretch = c(2, 1.5, 1) # the stretch which lines up the start and end points.
min_num_overlapping_points = 4 # will only allow shifts which leave this many overlapping points after applying the stretch
shift_extreme  = 4 # the absolute maximum value which can be applied as a shift. Noticed that in the shuffled genes,
transformed.timecourse = 'Col0' # the name of the timecourse to apply the registratsion to (one of the names in the mean_df$accession column)
                                # which is loaded at line 133.

num.shuffled <- 1 #25 # for real, ran 40 jobs to get 40 * 25 random shuffled pairs for comparison. 
```

## Setup flags

```{r}
# setup flags for rescaling options
if (do.initial_rescale=='rescale') {
  initial_rescale <- TRUE
} else {
  initial_rescale <- FALSE
}
if (do.register.rescale=='rescale') {
  should.rescale <- TRUE
} else {
  should.rescale <- FALSE
}

#real.and.shuffled <- c('real', 1)

if (initial_rescale==TRUE) {
  print('********************')
  print('will rescale the data prior to registering, and register using this rescaled mean data!')
  print('********************')
}
if (should.rescale==TRUE){
  print('********************')
  print('will rescale the data when deciding optimal registration!')
  print('********************')
} 
```

## Setup directory to set the path 

```{r}
# directories to save graphs to
real.data.graph.dir <- paste0('graphs/gene_registration/', outdir.string, '_real_data/')
shuffled.data.graph.dir <- paste0('graphs/gene_registration/', outdir.string, '_shuffled_data/job_', jobNum, '/')
# directories to save real and shuffled expression data to
real.expression.dir <- paste0('intermediate_data/gene_registration/', outdir.string, '_real_data/gene_expression/job_', jobNum, '/')
shuffled.expression.dir <- paste0('intermediate_data/gene_registration/', outdir.string, '_shuffled_data/gene_expression/')
# directories to save real and shuffled distance data to
real.distance.dir <- paste0('intermediate_data/gene_registration/', outdir.string, '_real_distance/job_', jobNum, '/')
shuffled.distance.dir <- paste0('intermediate_data/gene_registration/', outdir.string, '_shuffled_distance/')
  

# somewhere to store the data.tables and graphs
if (!(dir.exists(real.expression.dir))) {
    dir.create(real.expression.dir, recursive=T)
    dir.create(shuffled.expression.dir, recursive=T)
    
    dir.create(real.distance.dir, recursive=T)
    dir.create(shuffled.distance.dir, recursive=T)

    dir.create(real.data.graph.dir, recursive=T)
    dir.create(shuffled.data.graph.dir, recursive=T)
}
```

### Step 3 onwards: after getting all results of shift and stretch

```{r}
all_results_shift_stretch <- readRDS("strecth_shift_results_all_genes.rds")

all_shifts <- all_results_shift_stretch[['all_shifts']]
best_shifts <- all_results_shift_stretch[['best_shifts']]
model.comparison.dt <- all_results_shift_stretch[['model.comparison.dt']]
```

```{r}
all_results_shift_stretch %>% 
  summary()
```

```{r}
all_shifts %>% 
  dplyr::filter(gene == "BRAA01G000040.3C") 
```

```{r}
best_shifts %>% 
  head(5)
```


```{r}
model.comparison.dt %>% 
  head(5)
```

### Step 4: add more column of BIC/AIC statistical measurement

```{r}
# report model comparison results
model.comparison.dt$BIC.registered.is.better <- (model.comparison.dt$registered.BIC < model.comparison.dt$separate.BIC)
model.comparison.dt$AIC.registered.is.better <- (model.comparison.dt$registered.AIC < model.comparison.dt$separate.AIC)
model.comparison.dt$ABIC.registered.is.better <- (model.comparison.dt$BIC.registered.is.better & model.comparison.dt$AIC.registered.is.better)
print('################## Model comparison results #######################')
print(paste0('AIC finds registration better than separate for :', sum(model.comparison.dt$AIC.registered.is.better), ' / ', nrow(model.comparison.dt)))
print(paste0('BIC finds registration better than separate for :', sum(model.comparison.dt$BIC.registered.is.better), ' / ', nrow(model.comparison.dt)))
print(paste0('AIC & BIC finds registration better than separate for :', sum(model.comparison.dt$ABIC.registered.is.better), ' / ', nrow(model.comparison.dt)))
print('###################################################################')
```

```{r}
model.comparison.dt %>% 
  head(5)
```

### Step 5: apply shift to registered genes only


```{r}
# read RDS

to.shift.df <- readRDS("to_shift_df_all_genes.RDS")
all.data.df <- readRDS("all_data_df_all_genes.RDS")
```

```{r}
# The main function to apply shift to registered genes only
# shifted.mean_df <- apply_shift_to_registered_genes_only(to.shift.df, best_shifts, model.comparison.dt)
```

#### Step 5a: 

```{r}
# genes for which registration model is better than separate model
genes.to.register <- model.comparison.dt$gene[model.comparison.dt$BIC.registered.is.better]
genes.to.register %>% length()
```


```{r}
# apply the registration transformation to these genes

# since length(genes.to.register) > 0, then do:
register.dt <- to.shift.df[to.shift.df$locus_name %in% genes.to.register,]
register.dt %>% 
  nrow()
```

```{r}
to.shift.df %>% 
  nrow()
```


```{r}
registered.dt <- apply_best_shift(register.dt, best_shifts)
registered.dt %>% 
  dplyr::filter(locus_name == "BRAA03G023790.3C") %>% 
  knitr::kable()
```


```{r}
# added new column with all broadcasted "TRUE"
registered.dt$is.registered <- TRUE
```
```{r}
registered.dt %>% 
  summary()
```


#### Step 5a: 

```{r}
# genes for which the separate model is better than registration model
genes.to.keep.separate <- model.comparison.dt$gene[!(model.comparison.dt$BIC.registered.is.better)]
```


```{r}
# generate the columns for these needed to concat. with registered.dt
separate.dt <- to.shift.df[to.shift.df$locus_name %in% genes.to.keep.separate,]
separate.dt$stretched.time.delta <- 0 # in order to ensure that separate copy
# print('line 594')
# print(min(timepoint))
separate.dt[, stretched.time.delta:=timepoint - min(timepoint), by=.(locus_name, accession)]
separate.dt$shifted_time <- separate.dt$stretched.time.delta + 11 # add eleven, as this is done for the registered genes
# to make comparible between Ro18 and Col. Therefore need to to this
# here, to keep unregistered col0 in same frame as
# stretch 1, shift 0 registered genes.
separate.dt$is.registered <- FALSE
```

```{r}
separate.dt %>% 
  summary()
```


combine together: 

```{r}
out.dt <- rbind(registered.dt, separate.dt)

# change name like in the big function: 

shifted.mean_df <- out.dt
```

### Step 6: impute

Testing how the data looks after shifted for SOC1

```{r}
# sanity plotting - a registered one
ggplot2::ggplot(shifted.mean_df[shifted.mean_df$locus_name=='BRAA03G023790.3C', ])+
  ggplot2::aes(x=shifted_time, y=mean_cpm, color=accession)+
  ggplot2::geom_point()
```
```{r}
ggplot2::ggplot(shifted.mean_df[shifted.mean_df$locus_name=='BRAA05G005370.3C', ])+
  ggplot2::aes(x=shifted_time, y=mean_cpm, color=accession)+
  ggplot2::geom_point()
```


Take one gene, just to see how this works

```{r}
imputed.timepoints <- round(seq(min(shifted.mean_df$shifted_time), max(shifted.mean_df$shifted_time)))

curr.gene <- 'BRAA03G023790.3C' #unique(shifted.mean_df$locus_name)[17]

# get the current gene expression data
curr.df <- shifted.mean_df[shifted.mean_df$locus_name==curr.gene, ]

ara.df <- curr.df[curr.df$accession=='Col0',]
bra.df <- curr.df[curr.df$accession=='Ro18',]

interp.ara.df <- data.table::data.table(data.frame('locus_name'=curr.gene, 'accession'='Col0', 'tissue'='apex', 'timepoint'=NA,
                                                       'stretched.time.delta'= NA, 'shifted_time'=imputed.timepoints,
                                                       'is.registered'= unique(ara.df$is.registered)[1]))

# for each brassica timepoint, interpolate the comparible arabidopsis expression
# by linear interpolation between the neighbouring 2 ara values. If not between 2 ara values
# because shifted outside compatible range, set to NA
interp.ara.df$mean_cpm <- sapply(imputed.timepoints, interpolate_brassica_comparison_expression, bra.dt=ara.df)
```


```{r}
# sanity plotting - a registered one
ggplot2::ggplot(shifted.mean_df[shifted.mean_df$locus_name=='BRAA01G000040.3C', ])+
  ggplot2::aes(x=shifted_time, y=mean_cpm, color=accession)+
  ggplot2::geom_point()
```

```{r}
# sanity testing - line is interpolated.
ggplot2::ggplot(curr.df)+
  ggplot2::aes(x=shifted_time, y=mean_cpm, color=accession)+
  ggplot2::geom_point()+
  ggplot2::geom_line(data=interp.ara.df)
```


Now do it all, and try to do sanity check again: 

```{r}
imputed.mean_df <- impute_arabidopsis_values(shifted.mean_df)
```

```{r}
imputed.mean_df %>% 
  head(5)
```


```{r}
imputed.mean_df <- fix.accessions(imputed.mean_df, original.transformed.accession, original.other.accession)
```






















































